{-# LANGUAGE FlexibleInstances #-}
module SkelLatte where

-- Haskell module generated by the BNF converter

import           AbsLatte
import           ErrM

import           Control.Monad                  ( foldM )
import           Control.Monad.Except
import           Control.Monad.Reader
import           Control.Monad.State
import           Data.Bool
import           Data.List                      ( intercalate )
import qualified Data.Map                      as Map
import           Data.Maybe
import qualified Data.Set                      as Set


positionString line column =
    "Error at line " ++ show line ++ " column " ++ show column ++ ":\n"

exprPosition :: Expr a -> a
exprPosition expr = case expr of
    EVar    pos _   -> pos
    ELitInt pos _   -> pos
    ELitTrue  pos   -> pos
    ELitFalse pos   -> pos
    EApp pos _ _    -> pos
    EString pos _   -> pos
    EAccess pos _ _ -> pos
    Neg pos _       -> pos
    Not pos _       -> pos
    EMul pos _ _ _  -> pos
    EAdd pos _ _ _  -> pos
    ERel pos _ _ _  -> pos
    EAnd pos _ _    -> pos
    EOr  pos _ _    -> pos

type Result = Err String

data StaticType
    = TypeBool
    | TypeVoid
    | TypeInt
    | TypeStr
    | TypeNull
    | TypeCls Ident
    | TypeArr StaticType
    deriving (Ord)

instance Show StaticType where
    show TypeVoid        = "bool"
    show TypeBool        = "bool"
    show TypeInt         = "int"
    show TypeStr         = "string"
    show (TypeArr inner) = "[" ++ show inner ++ "]"

instance Eq StaticType where
    TypeInt    == TypeInt    = True
    TypeStr    == TypeStr    = True
    TypeBool   == TypeBool   = True
    TypeCls n1 == TypeCls n2 = n1 == n2
    TypeArr t1 == TypeArr t2 = t1 == t2
    _          == _          = False

data StaticException a = ArrayNotHomogenous a
    | VariableNotInScope a Ident
    | FunctionNotInScope a Ident
    | TypeMismatch a StaticType StaticType
    | CompareDifferentTypes a StaticType StaticType
    | AddNonAddable a
    | NonIndexable a StaticType
    | RedefinitionOfSymbol a Ident
    | NoReturn a Ident
    | WrongNumebrOfArguments a Int Int
    | NotSubclass a Ident Ident
    | MainNotDefined

instance Show (StaticException (Maybe (Int, Int))) where
    show (VariableNotInScope (Just (line, column)) ident) =
        positionString line column
            ++ "Variable "
            ++ show ident
            ++ " not in scope."
    show (FunctionNotInScope (Just (line, column)) ident) =
        positionString line column
            ++ "Function "
            ++ show ident
            ++ " not in scope."
    show (TypeMismatch (Just (line, column)) expected actual) =
        positionString line column
            ++ "Tried to use expresion of type "
            ++ show actual
            ++ " where expression of type "
            ++ show expected
            ++ " was expected."
    show (CompareDifferentTypes (Just (line, column)) t1 t2) =
        positionString line column
            ++ "Tried to compare expression of type "
            ++ show t1
            ++ " with expression of type "
            ++ show t2
            ++ "."
    show (AddNonAddable (Just (line, column))) =
        positionString line column ++ "Tried to add two boolean values"
    show (NonIndexable (Just (line, column)) t) =
        positionString line column
            ++ "Tried to index expression of type "
            ++ show t
            ++ "."
    show (RedefinitionOfSymbol (Just (line, column)) name) =
        positionString line column
            ++ "Multiple declarations of variable "
            ++ show name
            ++ "."
    show (NoReturn (Just (line, column)) name) =
        positionString line column
            ++ "Function "
            ++ show name
            ++ " does not return in all execution paths."
    show (WrongNumebrOfArguments (Just (line, column)) expected actual) =
        "Called function with wrong number of arguments, expected: "
            ++ show expected
            ++ ", provided: "
            ++ show actual
            ++ "."
    show MainNotDefined = "Error: main function not defined."
    show _              = "Udefined show"

type ERT a r = ReaderT StaticEnv (Except (StaticException a)) r

data StaticEnv = StaticEnv
    { _varMap :: VarMap
    , _funMap :: FunMap
    , _classMap :: ClassMap
    , _retType :: RetType
    , _nestLvl :: NestLvl
    }

type RetType = StaticType
type NestLvl = Integer
type Function = (StaticType, [(StaticType, Ident)])
type Field = StaticType

type InheritanceForest = Map.Map StaticType StaticType
type VarMap = Map.Map Ident (StaticType, NestLvl) -- nest level
type FunMap = Map.Map Ident Function -- function_name -> (return type, argument list, maybe class)
type ClassMap = Map.Map Ident ClassMeta

data ClassMeta = ClassMeta
    { _fields :: Map.Map Ident Field
    , _methods :: Map.Map Ident Function
    , _super :: Maybe Ident
    }

lookupFail err = maybe (throwError err) return

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x


-- transIdent :: Ident -> Result
-- transIdent x = case x of
--     Ident string -> failure x

-- TODO: pattern match may refuse when class is not present in env
superclass :: Show a => StaticType -> StaticType -> ERT a Bool
superclass _t1@(TypeCls t1) (TypeCls t2) = do
    maybeparent <- asks (Map.lookup t2 . _classMap)
    case maybeparent of
        (Just ClassMeta { _super = mparent }) -> do
            case mparent of
                (Just parent) -> if parent == t1
                    then return True
                    else superclass _t1 (TypeCls parent)
                Nothing -> return False
        Nothing -> return False

transProgram :: Show a => Program a -> Result
transProgram x = case x of
    Program _ topdefs -> failure x


transTopDef :: Show a => TopDef a -> Result
transTopDef x = case x of
    TopClassDef _ classdef -> failure x
    TopFunDef   _ fndef    -> failure x


transFnDef :: Show a => FnDef a -> Result
transFnDef x = case x of
    FnDef _ type_ ident args block -> failure x


transArg :: Show a => Arg a -> Result
transArg x = case x of
    Arg _ type_ ident -> failure x


transClassMember :: Show a => ClassMember a -> Result
transClassMember x = case x of
    ClassField _ type_ idents -> failure x
    ClassMethod _ fndef       -> failure x


transClassBlock :: Show a => ClassBlock a -> Result
transClassBlock (ClassBlock p classmembers) = do
    let fields = filter isField classmembers
    let methods = filter isMethod classmembers


  where
      isField x = case x of
                    (ClassMethod _ _) -> True
                    _ -> False
      isMethod = not . isField


transClassDef :: Show a => ClassDef a -> Result
transClassDef x = case x of
    Class _ ident classblock            -> failure x
    ClassInh _ ident1 ident2 classblock -> failure x


transBlock :: Show a => Block a -> Result
transBlock x = case x of
    Block _ stmts -> failure x


transStmt :: Show a => Stmt a -> ERT a ()
transStmt x = case x of
    Empty _                     -> return ()
    BStmt _ block               -> failure x
    Decl _ type_ items          -> failure x
    Ass  _ expr1 expr2          -> failure x
    Incr _ ident                -> failure x
    Decr _ ident                -> failure x
    Ret  _ expr                 -> failure x
    VRet _                      -> failure x
    Cond _ expr stmt            -> failure x
    CondElse _ expr stmt1 stmt2 -> failure x
    While _ expr stmt           -> failure x
    For _ type_ ident expr stmt -> failure x
    SExp _ expr                 -> failure x


transItem :: Show a => Item a -> ERT a ()
transItem x = case x of
    NoInit _ ident    -> return ()
    Init _ ident expr -> do
        exprType <- transExpr expr
        return ()


transClassType :: Show a => ClassType a -> StaticType
transClassType x = case x of
    BCType _ ident -> TypeCls ident


transBType :: Show a => BType a -> StaticType
transBType x = case x of
    Int  _ -> TypeInt
    Str  _ -> TypeStr
    Bool _ -> TypeBool


transNonVoidType :: Show a => NonVoidType a -> StaticType
transNonVoidType x = case x of
    CType _ (BCType _ ident) -> TypeCls ident
    BType _ btype            -> transBType btype


transType :: Show a => Type a -> StaticType
transType x = case x of
    ArrayType   _ nonvoidtype -> transNonVoidType nonvoidtype
    NonVoidType _ nonvoidtype -> transNonVoidType nonvoidtype
    Void _                    -> TypeVoid


transCastType :: Show a => CastType a -> StaticType
transCastType x = case x of
    CastTypeClass _ nonvoidtype -> transNonVoidType nonvoidtype
    CastTypeArr   _ nonvoidtype -> transNonVoidType nonvoidtype


transExpr :: Show a => Expr a -> ERT a StaticType
transExpr x = case x of
    ENewObject _ ident             -> failure x
    ENewArray _ nonvoidtype expr   -> failure x
    EMember   _ expr        ident  -> failure x
    EMemberCall _ expr ident exprs -> failure x
    EVar pos ident                 -> do
        fst
            <$> (   asks (Map.lookup ident . _varMap)
                >>= lookupFail (VariableNotInScope pos ident)
                )

    ELitInt _ integer        -> return TypeInt
    ELitTrue  _              -> return TypeBool
    ELitFalse _              -> return TypeBool
    ENull     _              -> return TypeNull
    EString _ string         -> return TypeStr
    EApp pos ident arguments -> do
        (returnType, argumentsTypes) <- asks (Map.lookup ident . _funMap)
            >>= lookupFail (FunctionNotInScope pos ident)
        when (length argumentsTypes /= length arguments)
            $ throwError
            $ WrongNumebrOfArguments pos
                                     (length argumentsTypes)
                                     (length arguments)
        zipWithM_
            (\t expr -> do
                exprType <- transExpr expr
                when (exprType /= t) $ throwError
                    (TypeMismatch (exprPosition expr) t exprType)
            )
            (map fst argumentsTypes)
            arguments
        return returnType
    EAccess _ expr1 expr2 -> failure x
    ECast   _ expr  cast  -> do
        exprType <- transExpr expr
        castType <- transExpr cast
        unless (exprType == TypeNull)
               (throwError TypeMismatch TypeNull exprType)
        return castType
    Neg _ expr               -> failure x
    Not _ expr               -> failure x
    EMul _ expr1 mulop expr2 -> failure x
    EAdd _ expr1 addop expr2 -> failure x
    ERel _ expr1 relop expr2 -> failure x
    EAnd _ expr1 expr2       -> failure x
    EOr  _ expr1 expr2       -> failure x
transAddOp :: Show a => AddOp a -> Result
transAddOp x = case x of
    Plus  _ -> failure x
    Minus _ -> failure x
transMulOp :: Show a => MulOp a -> Result
transMulOp x = case x of
    Times _ -> failure x
    Div   _ -> failure x
    Mod   _ -> failure x
transRelOp :: Show a => RelOp a -> Result
transRelOp x = case x of
    LTH _ -> failure x
    LE  _ -> failure x
    GTH _ -> failure x
    GE  _ -> failure x
    EQU _ -> failure x
    NE  _ -> failure x
